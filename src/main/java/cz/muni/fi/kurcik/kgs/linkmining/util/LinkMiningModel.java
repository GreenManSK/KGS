package cz.muni.fi.kurcik.kgs.linkmining.util;

import cz.muni.fi.kurcik.kgs.clustering.FuzzyClusteringModel;
import cz.muni.fi.kurcik.kgs.util.MaxIndex;

import java.util.ArrayList;

/**
 * Fuzzy model to compute indexes of clustering generated by link mining
 * @author Lukáš Kurčík
 */
public class LinkMiningModel implements FuzzyClusteringModel {

    protected double[][] matrix;

    /**
     * Creates new model
     * @param rankingMap Ranking map [documentId][clusterId]
     */
    public LinkMiningModel(double[][] rankingMap) {
        matrix = new double[rankingMap.length][rankingMap[0].length];
        for (int i = 0; i < rankingMap.length; i++) {
            double sum = 0;
            for (int j = 0; j < rankingMap[i].length; j++) {
                sum += rankingMap[i][j];
            }
            for (int j = 0; j < rankingMap[i].length; j++) {
                matrix[i][j] = rankingMap[i][j] / sum;
            }
        }
    }

    /**
     * Return cluster for document
     *
     * @param documentId document id
     * @return cluster id
     */
    @Override
    public int getCluster(int documentId) {
        return MaxIndex.max(getClusterMatrix(documentId));
    }

    /**
     * Return probability matrix of document
     *
     * @param documentId document id
     * @return array of probabilities for each cluster
     */
    @Override
    public double[] getClusterMatrix(int documentId) {
        return matrix[documentId];
    }

    /**
     * Return probability matrix of cluster
     *
     * @param clusterId cluster id
     * @return array of probabilities for each document
     */
    @Override
    public double[] getDocumentMatrix(int clusterId) {
        double[] probs = new double[matrix.length];

        for (int docId = 0; docId < matrix.length; docId++) {
            probs[docId] = matrix[docId][clusterId];
        }

        return probs;
    }

    /**
     * Return probability matrix for clustering
     *
     * @return [documentId][clusterId]
     */
    @Override
    public double[][] getProbabilityMatrix() {
        return matrix;
    }

    /**
     * Return number of clusters
     *
     * @return number of clusters
     */
    @Override
    public int getClusterCount() {
        return matrix[0].length;
    }

    /**
     * Return array of ids of all documents in this cluster
     *
     * @param clusterId cluster id
     * @return array of ids
     */
    @Override
    public int[] getDocuments(int clusterId) {
        ArrayList<Integer> docs = new ArrayList<>();

        for (int docId = 0; docId < matrix.length; ++docId) {
            if (clusterId == getCluster(docId))
                docs.add(docId + 1);
        }

        return docs.stream().mapToInt(Integer::intValue).toArray();
    }

    /**
     * Return number of documents
     *
     * @return number of documents
     */
    @Override
    public int getDocumentCount() {
        return matrix.length;
    }
}
